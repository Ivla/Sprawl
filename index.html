<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Sprawl</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: white; margin: 0; min-height: 100vh; }
        #lobby { background: #333; padding: 25px; border-radius: 12px; margin-top: 30px; width: 450px; text-align: center; border: 1px solid #555; }
        .connection-step { margin: 15px 0; padding: 15px; background: #222; border-radius: 8px; }
        input { padding: 10px; border-radius: 5px; border: 1px solid #555; width: 180px; background: #000; color: #f1c40f; font-family: monospace; font-size: 1.2em; text-align: center; }
        button { padding: 10px 20px; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 5px; font-weight: bold; transition: background 0.2s; }
        button:hover { background: #2ecc71; }
        
        #game-container { display: none; flex-direction: column; align-items: center; padding-bottom: 50px; }
        #game-info { margin: 20px; text-align: center; background: #333; padding: 20px; border-radius: 15px; border: 1px solid #555; width: 460px; }
        .score-board { display: flex; gap: 60px; font-size: 1.6em; margin-top: 15px; justify-content: center; }
        .score-box { position: relative; display: flex; flex-direction: column; align-items: center; width: 130px; }
        .crown { font-size: 30px; position: absolute; top: -38px; display: none; animation: bounce 1s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        #board { display: grid; grid-template-columns: repeat(15, 30px); gap: 1px; background: #444; border: 5px solid #000; }
        .cell { width: 30px; height: 30px; background: #2c2c2c; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; transition: background 0.2s; }
        .cell.invalid { background: #111; }
        .cell.disputed { background: #4a4a4a !important; box-shadow: inset 0 0 5px #000; }

        .piece { width: 22px; height: 22px; border-radius: 50%; z-index: 10; border: 2px solid rgba(255,255,255,0.3); }
        .piece.p1 { background: #ff4757; box-shadow: 0 0 15px #ff4757; }
        .piece.p2 { background: #2e86de; box-shadow: 0 0 15px #2e86de; }
        .line { position: absolute; z-index: 1; opacity: 0.8; }
        .line.v { width: 4px; height: 100%; }
        .line.h { height: 4px; width: 100%; }
        .line.p1 { background: #ff4757; }
        .line.p2 { background: #2e86de; }

        #game-controls { margin-top: 25px; display: none; }
        .reset-btn { background: #e67e22; padding: 12px 30px; font-size: 1.1em; }
        .reset-btn:hover { background: #f39c12; }
        
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(8px); }
        #result-card { background: #222; padding: 40px; border-radius: 20px; border: 3px solid #f1c40f; text-align: center; }
        #turn-display { font-size: 1.2em; color: #f1c40f; font-weight: bold; }
        #status-msg { font-size: 0.9em; color: #00ff00; margin-top: 10px; font-family: monospace; }
        .ai-btn { background: #2e86de; margin-top: 10px; }
    </style>
</head>
<body>

<div id="lobby">
    <h1 style="color: #f1c40f; margin-bottom: 20px;">SPRAWL</h1>
    <div class="connection-step">
        <div style="margin-bottom: 5px;">æ‚¨çš„æˆ¿è™Ÿ (ID)</div>
        <b id="my-id" style="font-size: 1.5em; color: #fff; letter-spacing: 2px;">ç”Ÿæˆä¸­...</b><br>
        <button onclick="copyMyID()" style="margin-top: 10px; background: #444;">è¤‡è£½æˆ¿è™Ÿ</button>
    </div>
    <div class="connection-step">
        <input type="text" id="peer-id-input" placeholder="å°æ‰‹çš„æˆ¿è™Ÿ" maxlength="5">
        <button onclick="connectToPeer()">åŠ å…¥æˆ¿é–“</button>
        <div style="margin: 15px 0; color: #888;">â€” æˆ– â€”</div>
        <button class="ai-btn" onclick="startAIMode()">èˆ‡ AI å°æˆ°</button>
    </div>
    <div id="status-msg">æ­£åœ¨å°‹æ‰¾ä¼ºæœå™¨...</div>
</div>

<div id="game-container">
    <div id="game-info">
        <div id="turn-display">åŒæ­¥ä¸­...</div>
        <div class="score-board">
            <div class="score-box">
                <div id="crown-p1" class="crown">ğŸ‘‘</div>
                <div id="label-p1" class="player-label" style="color: #ff4757; font-weight: bold;">ç´…æ–¹ (P1)</div>
                <div id="p1-score">0</div>
            </div>
            <div class="score-box">
                <div id="crown-p2" class="crown">ğŸ‘‘</div>
                <div id="label-p2" class="player-label" style="color: #2e86de; font-weight: bold;">è—æ–¹ (P2)</div>
                <div id="p2-score">0</div>
            </div>
        </div>
    </div>
    <div id="board"></div>
    <div id="game-controls">
        <button class="reset-btn" onclick="location.reload()">å†ä¾†ä¸€å±€</button>
    </div>
</div>

<div id="overlay">
    <div id="result-card">
        <h1 id="win-text">éŠæˆ²çµæŸ</h1>
        <div style="display: flex; gap: 40px; font-size: 2em; margin: 20px 0; justify-content: center;">
            <div style="color: #ff4757;">ç´…: <span id="final-p1">0</span></div>
            <div style="color: #2e86de;">è—: <span id="final-p2">0</span></div>
        </div>
        <div style="color: #888; font-size: 0.9em;">è¦–çª—å°‡åœ¨ 3 ç§’å¾Œè‡ªå‹•é—œé–‰...</div>
    </div>
</div>

<script>
    function generateShortId() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789';
        let result = '';
        for (let i = 0; i < 5; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    const SIZE = 15;
    let board = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
    let connectionsData = [];
    let gameOver = false;
    let peer, conn;
    let myPlayerNum = 0; 
    let currentTurnPlayer = 1;
    let isAIMode = false;

    function initPeer() {
        const shortId = generateShortId();
        peer = new Peer(shortId, {
            config: { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] },
            debug: 2
        });
        peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
            document.getElementById('status-msg').innerText = "â— ä¼ºæœå™¨å°±ç·’";
        });
        peer.on('connection', (c) => {
            if (conn || isAIMode) { c.close(); return; }
            conn = c;
            myPlayerNum = 1;
            setupListeners();
        });
    }

    function startAIMode() {
        isAIMode = true;
        myPlayerNum = 1;
        startGameUI();
    }

    function connectToPeer() {
        const targetId = document.getElementById('peer-id-input').value.trim();
        if (!targetId) return;
        conn = peer.connect(targetId);
        myPlayerNum = 2;
        setupListeners();
    }

    function setupListeners() {
        conn.on('open', () => { conn.send({ type: 'handshake' }); });
        conn.on('data', (data) => {
            if (data.type === 'handshake') {
                startGameUI();
                if (myPlayerNum === 1) conn.send({ type: 'handshake' });
            } else if (data.type === 'move') {
                executeTurn(data.r, data.c, data.player);
            }
        });
        conn.on('close', () => { alert("å°æ‰‹æ–·ç·š"); location.reload(); });
    }

    function startGameUI() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'flex';
        
        const lp1 = document.getElementById('label-p1');
        const lp2 = document.getElementById('label-p2');

        if (isAIMode) {
            lp1.innerText = "æ‚¨ (ç´…æ–¹)";
            lp2.innerText = "AI (è—æ–¹)";
        } else {
            if (myPlayerNum === 1) {
                lp1.innerText = "æ‚¨ (ç´…æ–¹)";
                lp2.innerText = "å°æ‰‹ (è—æ–¹)";
            } else {
                lp1.innerText = "å°æ‰‹ (ç´…æ–¹)";
                lp2.innerText = "æ‚¨ (è—æ–¹)";
            }
        }
        updateTurnDisplay();
        createBoard();
    }

    function handleMove(r, c) {
        if (gameOver || currentTurnPlayer !== myPlayerNum) return;
        if (!isAIMode && (!conn || !conn.open)) return;
        if (isValidMove(r, c, myPlayerNum)) {
            if (!isAIMode) conn.send({ type: 'move', r, c, player: myPlayerNum });
            executeTurn(r, c, myPlayerNum);
        }
    }

    function executeTurn(r, c, player) {
        board[r][c] = player;
        growLines();
        findNewConnections(r, c, player);
        updateScore();
        if (!checkGameOver()) {
            currentTurnPlayer = (player === 1) ? 2 : 1;
            updateTurnDisplay();
            render(); 
            if (isAIMode && currentTurnPlayer === 2) setTimeout(aiMove, 600);
        } else {
            render();
        }
    }

    function updateTurnDisplay() {
        const d = document.getElementById('turn-display');
        d.innerText = currentTurnPlayer === myPlayerNum ? "â˜… æ‚¨çš„å›åˆ â˜…" : (isAIMode ? "AI æ­£åœ¨æ€è€ƒ..." : "ç­‰å¾…å°æ‰‹è½å­...");
        d.style.color = currentTurnPlayer === myPlayerNum ? "#f1c40f" : "#aaa";
    }

    function createBoard() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => handleMove(r, c);
                b.appendChild(cell);
            }
        }
        render();
    }

    function getLinesAt(r, c) {
        return connectionsData.filter(t => t.path.some(p => p.r === r && p.c === c));
    }

    function isValidMove(r, c, player) {
        if (board[r][c] !== 0) return false;
        return !getLinesAt(r, c).some(l => l.player === (player === 1 ? 2 : 1));
    }

    function render() {
        for(let r=0; r<SIZE; r++) {
            for(let c=0; c<SIZE; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                if (!cell) continue;
                cell.innerHTML = ''; 
                const lines = getLinesAt(r, c);
                const h1 = lines.some(l => l.player === 1) || board[r][c] === 1;
                const h2 = lines.some(l => l.player === 2) || board[r][c] === 2;
                cell.classList.remove('invalid', 'disputed');
                if (h1 && h2) cell.classList.add('disputed');
                else if (!isValidMove(r, c, currentTurnPlayer)) cell.classList.add('invalid');

                if (board[r][c] !== 0) {
                    const p = document.createElement('div');
                    p.className = `piece p${board[r][c]}`;
                    cell.appendChild(p);
                }
                lines.forEach(l => {
                    const lineEl = document.createElement('div');
                    lineEl.className = `line ${l.dr !== 0 ? 'v' : 'h'} p${l.player}`;
                    cell.appendChild(lineEl);
                });
            }
        }
    }

    function aiMove() {
        if (gameOver) return;
        let possible = [];
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (isValidMove(r, c, 2)) possible.push({ r, c, score: evaluateMove(r, c) });
            }
        }
        if (possible.length > 0) {
            possible.sort((a, b) => b.score - a.score);
            let choice = possible.slice(0, 2)[Math.floor(Math.random() * Math.min(2, possible.length))];
            executeTurn(choice.r, choice.c, 2);
        }
    }

    function evaluateMove(r, c) {
        let s = Math.random() * 2;
        const lines = getLinesAt(r, c);
        if (!lines.some(l => l.player === 2) && !lines.some(l => l.player === 1)) s += 10;
        connectionsData.forEach(t => {
            if (t.player === 1 && t.active) {
                const last = t.path.length === 0 ? t.origin : t.path[t.path.length - 1];
                if (r === last.r + t.dr && c === last.c + t.dc) s += 60;
            }
        });
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let cr = r + dr, cc = c + dc, dist = 0;
            while(cr >= 0 && cr < SIZE && cc >= 0 && cc < SIZE) {
                if (board[cr][cc] === 2) { s += (15 + dist * 2); break; }
                if (board[cr][cc] === 1) break;
                cr += dr; cc += dc; dist++;
            }
        });
        return s;
    }

    function growLines() {
        connectionsData.forEach(t => {
            if (!t.active) return;
            const last = t.path.length === 0 ? t.origin : t.path[t.path.length - 1];
            const nr = last.r + t.dr, nc = last.c + t.dc;
            if (nr === t.target.r && nc === t.target.c) { t.active = false; return; }
            if (board[nr][nc] !== 0 && board[nr][nc] !== t.player) { t.active = false; return; }
            if (getLinesAt(nr, nc).some(l => (l.dr !== 0 ? 'v' : 'h') === (t.dr !== 0 ? 'v' : 'h'))) { t.active = false; return; }
            t.path.push({r: nr, c: nc});
        });
    }

    function findNewConnections(r, c, p) {
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let cr = r + dr, cc = c + dc, found = false;
            while(cr >= 0 && cr < SIZE && cc >= 0 && cc < SIZE) {
                if (board[cr][cc] !== 0) { if (board[cr][cc] === p) found = true; break; }
                cr += dr; cc += dc;
            }
            if (found) connectionsData.push({ origin: {r, c}, target: {r: cr, c: cc}, dr, dc, player: p, path: [], active: true });
        });
    }

    function updateScore() {
        let p1 = 0, p2 = 0;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const lines = getLinesAt(r, c);
                const h1 = board[r][c] === 1 || lines.some(l => l.player === 1);
                const h2 = board[r][c] === 2 || lines.some(l => l.player === 2);
                if (h1 && h2) continue; 
                if (h1) p1++; else if (h2) p2++;
            }
        }
        document.getElementById('p1-score').innerText = p1;
        document.getElementById('p2-score').innerText = p2;
        return { p1, p2 };
    }

    function checkGameOver() {
        let all = true;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (board[r][c] === 0 && getLinesAt(r, c).length === 0) { all = false; break; }
            }
            if (!all) break;
        }
        if (all) {
            gameOver = true;
            const s = updateScore();
            showResult(s);
            return true;
        }
        return false;
    }

    function showResult(s) {
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('final-p1').innerText = s.p1;
        document.getElementById('final-p2').innerText = s.p2;
        const wt = document.getElementById('win-text');
        if (s.p1 > s.p2) { wt.innerText = "ğŸ‰ ç´…æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p1').style.display = 'block'; }
        else if (s.p2 > s.p1) { wt.innerText = "ğŸ‰ è—æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p2').style.display = 'block'; }
        else { wt.innerText = "âš–ï¸ å¹³æ‰‹ï¼"; }
        
        setTimeout(() => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('game-controls').style.display = 'block';
            document.getElementById('turn-display').innerText = "éŠæˆ²å·²çµæŸ";
        }, 3000);
    }

    function copyMyID() {
        const id = document.getElementById('my-id').innerText;
        if (id.includes("ç”Ÿæˆ")) return;
        navigator.clipboard.writeText(id).then(() => alert("æˆ¿è™Ÿå·²è¤‡è£½ï¼"));
    }

    initPeer();
</script>

</body>
</html>

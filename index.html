<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Lacing War - Online & AI Version</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: white; margin: 0; min-height: 100vh; }
        #lobby { background: #333; padding: 25px; border-radius: 12px; margin-top: 30px; width: 450px; text-align: center; border: 1px solid #555; }
        .connection-step { margin: 15px 0; padding: 15px; background: #222; border-radius: 8px; }
        input { padding: 10px; border-radius: 5px; border: 1px solid #555; width: 180px; background: #000; color: #f1c40f; font-family: monospace; font-size: 1.2em; text-align: center; }
        button { padding: 10px 20px; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 5px; font-weight: bold; }
        #game-container { display: none; flex-direction: column; align-items: center; padding-bottom: 50px; }
        #game-info { margin: 20px; text-align: center; background: #333; padding: 20px; border-radius: 15px; border: 1px solid #555; width: 460px; }
        .score-board { display: flex; gap: 60px; font-size: 1.6em; margin-top: 15px; justify-content: center; }
        .score-box { position: relative; display: flex; flex-direction: column; align-items: center; width: 130px; }
        .crown { font-size: 30px; position: absolute; top: -38px; display: none; animation: bounce 1s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        #board { display: grid; grid-template-columns: repeat(15, 30px); gap: 1px; background: #444; border: 5px solid #000; }
        .cell { width: 30px; height: 30px; background: #2c2c2c; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .cell.disputed { background: #444; }
        .piece { width: 22px; height: 22px; border-radius: 50%; z-index: 10; border: 2px solid rgba(255,255,255,0.3); }
        .piece.p1 { background: #ff4757; box-shadow: 0 0 15px #ff4757; }
        .piece.p2 { background: #2e86de; box-shadow: 0 0 15px #2e86de; }
        .line { position: absolute; z-index: 1; opacity: 0.8; }
        .line.v { width: 4px; height: 100%; }
        .line.h { height: 4px; width: 100%; }
        .line.p1 { background: #ff4757; }
        .line.p2 { background: #2e86de; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(8px); }
        #result-card { background: #222; padding: 40px; border-radius: 20px; border: 3px solid #f1c40f; text-align: center; }
        #turn-display { font-size: 1.2em; color: #f1c40f; font-weight: bold; }
        #status-msg { font-size: 0.9em; color: #00ff00; margin-top: 10px; font-family: monospace; }
        .ai-btn { background: #2e86de; margin-top: 10px; }
        .ai-btn:hover { background: #3498db; }
    </style>
</head>
<body>

<div id="lobby">
    <h2 style="color: #f1c40f;">Lacing War</h2>
    <div class="connection-step">
        <div style="margin-bottom: 5px;">æ‚¨çš„æˆ¿è™Ÿ (ID)</div>
        <b id="my-id" style="font-size: 1.5em; color: #fff; letter-spacing: 2px;">ç”Ÿæˆä¸­...</b><br>
        <button onclick="copyMyID()" style="margin-top: 10px; background: #444;">è¤‡è£½æˆ¿è™Ÿ</button>
    </div>
    <div class="connection-step">
        <input type="text" id="peer-id-input" placeholder="å°æ‰‹çš„æˆ¿è™Ÿ" maxlength="5">
        <button onclick="connectToPeer()">åŠ å…¥æˆ¿é–“</button>
        <div style="margin: 15px 0; color: #888;">â€” æˆ– â€”</div>
        <button class="ai-btn" onclick="startAIMode()">èˆ‡ AI å°æˆ°</button>
    </div>
    <div id="status-msg">æ­£åœ¨å°‹æ‰¾ PeerJS ä¼ºæœå™¨...</div>
</div>

<div id="game-container">
    <div id="game-info">
        <div id="turn-display">åŒæ­¥ä¸­...</div>
        <div class="score-board">
            <div class="score-box">
                <div id="crown-p1" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #ff4757;">æ‚¨ (ç´…æ–¹)</div>
                <div id="p1-score">0</div>
            </div>
            <div class="score-box">
                <div id="crown-p2" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #2e86de;">å°æ‰‹ (è—æ–¹)</div>
                <div id="p2-score">0</div>
            </div>
        </div>
    </div>
    <div id="board"></div>
</div>

<div id="overlay">
    <div id="result-card">
        <h1 id="win-text">éŠæˆ²çµæŸ</h1>
        <div style="display: flex; gap: 40px; font-size: 2em; margin: 20px 0; justify-content: center;">
            <div style="color: #ff4757;">ç´…: <span id="final-p1">0</span></div>
            <div style="color: #2e86de;">è—: <span id="final-p2">0</span></div>
        </div>
        <button onclick="location.reload()">å›å¤§å»³</button>
    </div>
</div>

<script>
    function generateShortId() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789';
        let result = '';
        for (let i = 0; i < 5; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    const SIZE = 15;
    let board = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
    let connectionsData = [];
    let gameOver = false;
    let peer, conn;
    let myPlayerNum = 0; 
    let currentTurnPlayer = 1;
    let isAIMode = false;

    function initPeer() {
        const shortId = generateShortId();
        peer = new Peer(shortId, {
            config: { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] },
            debug: 2
        });

        peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
            document.getElementById('status-msg').innerText = "â— ä¼ºæœå™¨å°±ç·’ï¼Œè«‹é€£ç·šæˆ–é¸æ“‡ AI æ¨¡å¼";
        });

        peer.on('connection', (c) => {
            if (conn || isAIMode) { c.close(); return; }
            conn = c;
            myPlayerNum = 1;
            setupListeners();
        });

        peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                location.reload();
            } else {
                document.getElementById('status-msg').innerText = "é€£ç·šéŒ¯èª¤: " + err.type;
            }
        });
    }

    function startAIMode() {
        isAIMode = true;
        myPlayerNum = 1; // ç©å®¶å§‹çµ‚ç‚ºç´…æ–¹
        startGameUI();
    }

    function connectToPeer() {
        const targetId = document.getElementById('peer-id-input').value.trim();
        if (!targetId) return;
        
        document.getElementById('status-msg').innerText = "â— æ­£åœ¨åŠ å…¥æˆ¿é–“ " + targetId + "...";
        conn = peer.connect(targetId);
        myPlayerNum = 2;
        setupListeners();
    }

    function setupListeners() {
        conn.on('open', () => {
            document.getElementById('status-msg').innerText = "â— é€£ç·šæˆåŠŸ";
            conn.send({ type: 'handshake' });
        });

        conn.on('data', (data) => {
            if (data.type === 'handshake') {
                startGameUI();
                if (myPlayerNum === 1) conn.send({ type: 'handshake' });
            } else if (data.type === 'move') {
                executeTurn(data.r, data.c, data.player);
            }
        });

        conn.on('close', () => {
            alert("å°æ‰‹æ–·ç·š");
            location.reload();
        });
    }

    function startGameUI() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'flex';
        updateTurnDisplay();
        
        const labels = document.querySelectorAll('.player-label');
        if (isAIMode) {
            labels[0].innerText = "æ‚¨ (ç´…æ–¹)";
            labels[1].innerText = "AI (è—æ–¹)";
        } else {
            if (myPlayerNum === 1) {
                labels[0].innerText = "æ‚¨ (ç´…æ–¹)";
                labels[1].innerText = "å°æ‰‹ (è—æ–¹)";
            } else {
                labels[0].innerText = "å°æ‰‹ (ç´…æ–¹)";
                labels[1].innerText = "æ‚¨ (è—æ–¹)";
            }
        }
        createBoard();
    }

    function handleMove(r, c) {
        if (gameOver || currentTurnPlayer !== myPlayerNum) return;
        if (!isAIMode && (!conn || !conn.open)) return;

        if (isValidMove(r, c, myPlayerNum)) {
            if (!isAIMode) conn.send({ type: 'move', r, c, player: myPlayerNum });
            executeTurn(r, c, myPlayerNum);
        }
    }

    function executeTurn(r, c, player) {
        board[r][c] = player;
        growLines();
        findNewConnections(r, c, player);
        render();
        updateScore();
        if (!checkGameOver()) {
            currentTurnPlayer = (player === 1) ? 2 : 1;
            updateTurnDisplay();
            
            // å¦‚æœæ˜¯ AI å›åˆï¼Œè§¸ç™¼ AI æ€è€ƒ
            if (isAIMode && currentTurnPlayer === 2) {
                setTimeout(aiMove, 600);
            }
        }
    }

    function updateTurnDisplay() {
        const d = document.getElementById('turn-display');
        d.innerText = currentTurnPlayer === myPlayerNum ? "â˜… æ‚¨çš„å›åˆ â˜…" : (isAIMode ? "AI æ­£åœ¨æ€è€ƒ..." : "ç­‰å¾…å°æ‰‹è½å­...");
        d.style.color = currentTurnPlayer === myPlayerNum ? "#f1c40f" : "#aaa";
    }

    // --- AI é‚è¼¯ ---
    function aiMove() {
        if (gameOver) return;

        let possibleMoves = [];
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (isValidMove(r, c, 2)) {
                    let score = evaluateMove(r, c);
                    possibleMoves.push({ r, c, score });
                }
            }
        }

        if (possibleMoves.length > 0) {
            possibleMoves.sort((a, b) => b.score - a.score);
            let topTier = possibleMoves.slice(0, 2);
            let choice = topTier[Math.floor(Math.random() * topTier.length)];
            executeTurn(choice.r, choice.c, 2);
        }
    }

    function evaluateMove(r, c) {
        let score = Math.random() * 2;
        const cellLines = getLinesAt(r, c);
        const hasOwnLine = cellLines.some(l => l.player === 2);
        const hasEnemyLine = cellLines.some(l => l.player === 1);

        if (!hasOwnLine && !hasEnemyLine) score += 10;
        if (hasOwnLine) score += 5;

        // é˜²ç¦¦ï¼šé˜»æ–·ç©å®¶
        connectionsData.forEach(task => {
            if (task.player === 1 && task.active) {
                const last = task.path.length === 0 ? task.origin : task.path[task.path.length - 1];
                if (r === last.r + task.dr && c === last.c + task.dc) score += 60;
            }
        });

        // æ“´å¼µï¼šé€£ç·šæ½›åŠ›
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let cr = r + dr, cc = c + dc, dist = 0;
            while(cr >= 0 && cr < SIZE && cc >= 0 && cc < SIZE) {
                if (board[cr][cc] === 2) { score += (15 + dist * 2); break; }
                if (board[cr][cc] === 1) break;
                cr += dr; cc += dc; dist++;
            }
        });

        if (hasEnemyLine) score += 15;
        const centerDist = Math.abs(r - 7) + Math.abs(c - 7);
        score += (14 - centerDist) * 0.3;

        return score;
    }

    // --- æ ¸å¿ƒåº•å±¤é‚è¼¯ ---
    function createBoard() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => handleMove(r, c);
                b.appendChild(cell);
            }
        }
        render();
    }

    function getLinesAt(r, c) {
        return connectionsData.filter(t => t.path.some(p => p.r === r && p.c === c));
    }

    function isValidMove(r, c, player) {
        if (board[r][c] !== 0) return false;
        return !getLinesAt(r, c).some(l => l.player === (player === 1 ? 2 : 1));
    }

    function findNewConnections(r, c, player) {
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let cr = r + dr, cc = c + dc, found = false;
            while(cr >= 0 && cr < SIZE && cc >= 0 && cc < SIZE) {
                if (board[cr][cc] !== 0) {
                    if (board[cr][cc] === player) found = true;
                    break;
                }
                cr += dr; cc += dc;
            }
            if (found) connectionsData.push({ origin: {r, c}, target: {r: cr, c: cc}, dr, dc, player, path: [], active: true });
        });
    }

    function growLines() {
        connectionsData.forEach(task => {
            if (!task.active) return;
            const last = task.path.length === 0 ? task.origin : task.path[task.path.length - 1];
            const nr = last.r + task.dr, nc = last.c + task.dc;
            if (nr === task.target.r && nc === task.target.c) { task.active = false; return; }
            if (board[nr][nc] !== 0 && board[nr][nc] !== task.player) { task.active = false; return; }
            const curDir = task.dr !== 0 ? 'v' : 'h';
            if (getLinesAt(nr, nc).some(l => (l.dr !== 0 ? 'v' : 'h') === curDir)) { task.active = false; return; }
            task.path.push({r: nr, c: nc});
        });
    }

    function render() {
        for(let r=0; r<SIZE; r++) {
            for(let c=0; c<SIZE; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                if (!cell) continue;
                cell.innerHTML = ''; cell.classList.remove('disputed');
                if (board[r][c] !== 0) {
                    const p = document.createElement('div');
                    p.className = `piece p${board[r][c]}`;
                    cell.appendChild(p);
                }
                const lines = getLinesAt(r, c);
                const h1 = lines.some(l => l.player === 1) || board[r][c] === 1;
                const h2 = lines.some(l => l.player === 2) || board[r][c] === 2;
                if (h1 && h2) cell.classList.add('disputed');
                lines.forEach(l => {
                    const lineEl = document.createElement('div');
                    lineEl.className = `line ${l.dr !== 0 ? 'v' : 'h'} p${l.player}`;
                    cell.appendChild(lineEl);
                });
            }
        }
    }

    function updateScore() {
        let p1 = 0, p2 = 0;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const lines = getLinesAt(r, c);
                const h1 = board[r][c] === 1 || lines.some(l => l.player === 1);
                const h2 = board[r][c] === 2 || lines.some(l => l.player === 2);
                if (h1 && h2) continue; 
                if (h1) p1++; else if (h2) p2++;
            }
        }
        document.getElementById('p1-score').innerText = p1;
        document.getElementById('p2-score').innerText = p2;
        return { p1, p2 };
    }

    function checkGameOver() {
        let all = true;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (board[r][c] === 0 && getLinesAt(r, c).length === 0) { all = false; break; }
            }
            if (!all) break;
        }
        if (all) {
            gameOver = true;
            const s = updateScore();
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-p1').innerText = s.p1;
            document.getElementById('final-p2').innerText = s.p2;
            const wt = document.getElementById('win-text');
            if (s.p1 > s.p2) { wt.innerText = "ğŸ‰ ç´…æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p1').style.display = 'block'; }
            else if (s.p2 > s.p1) { wt.innerText = "ğŸ‰ è—æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p2').style.display = 'block'; }
            else { wt.innerText = "âš–ï¸ å¹³æ‰‹ï¼"; }
            return true;
        }
        return false;
    }

    function copyMyID() {
        const id = document.getElementById('my-id').innerText;
        if (id.includes("ç”Ÿæˆ")) return;
        navigator.clipboard.writeText(id).then(() => alert("æˆ¿è™Ÿå·²è¤‡è£½ï¼"));
    }

    initPeer();
</script>

</body>
</html>

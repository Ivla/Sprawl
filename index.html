<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Lacing War - Short ID Version</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: white; margin: 0; min-height: 100vh; }
        #lobby { background: #333; padding: 25px; border-radius: 12px; margin-top: 30px; width: 450px; text-align: center; border: 1px solid #555; }
        .connection-step { margin: 15px 0; padding: 15px; background: #222; border-radius: 8px; }
        input { padding: 10px; border-radius: 5px; border: 1px solid #555; width: 180px; background: #000; color: #f1c40f; font-family: monospace; font-size: 1.2em; text-align: center; }
        button { padding: 10px 20px; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 5px; font-weight: bold; }
        #game-container { display: none; flex-direction: column; align-items: center; padding-bottom: 50px; }
        #game-info { margin: 20px; text-align: center; background: #333; padding: 20px; border-radius: 15px; border: 1px solid #555; width: 460px; }
        .score-board { display: flex; gap: 60px; font-size: 1.6em; margin-top: 15px; justify-content: center; }
        .score-box { position: relative; display: flex; flex-direction: column; align-items: center; width: 130px; }
        .crown { font-size: 30px; position: absolute; top: -38px; display: none; animation: bounce 1s infinite alternate; }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        #board { display: grid; grid-template-columns: repeat(15, 30px); gap: 1px; background: #444; border: 5px solid #000; }
        .cell { width: 30px; height: 30px; background: #2c2c2c; display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative; }
        .cell.disputed { background: #444; }
        .piece { width: 22px; height: 22px; border-radius: 50%; z-index: 10; border: 2px solid rgba(255,255,255,0.3); }
        .piece.p1 { background: #ff4757; box-shadow: 0 0 15px #ff4757; }
        .piece.p2 { background: #2e86de; box-shadow: 0 0 15px #2e86de; }
        .line { position: absolute; z-index: 1; opacity: 0.8; }
        .line.v { width: 4px; height: 100%; }
        .line.h { height: 4px; width: 100%; }
        .line.p1 { background: #ff4757; }
        .line.p2 { background: #2e86de; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(8px); }
        #result-card { background: #222; padding: 40px; border-radius: 20px; border: 3px solid #f1c40f; text-align: center; }
        #turn-display { font-size: 1.2em; color: #f1c40f; font-weight: bold; }
        #status-msg { font-size: 0.9em; color: #00ff00; margin-top: 10px; font-family: monospace; }
    </style>
</head>
<body>

<div id="lobby">
    <h2 style="color: #f1c40f;">Lacing War</h2>
    <div class="connection-step">
        <div style="margin-bottom: 5px;">æ‚¨çš„æˆ¿è™Ÿ (ID)</div>
        <b id="my-id" style="font-size: 1.5em; color: #fff; letter-spacing: 2px;">ç”Ÿæˆä¸­...</b><br>
        <button onclick="copyMyID()" style="margin-top: 10px; background: #444;">è¤‡è£½æˆ¿è™Ÿ</button>
    </div>
    <div class="connection-step">
        <input type="text" id="peer-id-input" placeholder="å°æ‰‹çš„æˆ¿è™Ÿ" maxlength="5">
        <button onclick="connectToPeer()">åŠ å…¥æˆ¿é–“</button>
    </div>
    <div id="status-msg">æ­£åœ¨å°‹æ‰¾ PeerJS ä¼ºæœå™¨...</div>
</div>

<div id="game-container">
    <div id="game-info">
        <div id="turn-display">åŒæ­¥ä¸­...</div>
        <div class="score-board">
            <div class="score-box">
                <div id="crown-p1" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #ff4757;">ç´…æ–¹ (P1)</div>
                <div id="p1-score">0</div>
            </div>
            <div class="score-box">
                <div id="crown-p2" class="crown">ğŸ‘‘</div>
                <div class="player-label" style="color: #2e86de;">è—æ–¹ (P2)</div>
                <div id="p2-score">0</div>
            </div>
        </div>
    </div>
    <div id="board"></div>
</div>

<div id="overlay">
    <div id="result-card">
        <h1 id="win-text">éŠæˆ²çµæŸ</h1>
        <div style="display: flex; gap: 40px; font-size: 2em; margin: 20px 0; justify-content: center;">
            <div style="color: #ff4757;">ç´…: <span id="final-p1">0</span></div>
            <div style="color: #2e86de;">è—: <span id="final-p2">0</span></div>
        </div>
        <button onclick="location.reload()">å›å¤§å»³</button>
    </div>
</div>

<script>
    // ç”Ÿæˆ 5 ä½éš¨æ©Ÿè‹±æ•¸å­—
    function generateShortId() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789';
        let result = '';
        for (let i = 0; i < 5; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    const SIZE = 15;
    let board = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
    let connectionsData = [];
    let gameOver = false;
    let peer, conn;
    let myPlayerNum = 0; 
    let currentTurnPlayer = 1;

    function initPeer() {
        const shortId = generateShortId();
        // æŒ‡å®š ID åˆå§‹åŒ–
        peer = new Peer(shortId, {
            config: { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] },
            debug: 2
        });

        peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
            document.getElementById('status-msg').innerText = "â— ä¼ºæœå™¨å°±ç·’ï¼Œè«‹å‘ŠçŸ¥å°æ‰‹æˆ¿è™Ÿ";
        });

        peer.on('connection', (c) => {
            if (conn) { c.close(); return; }
            conn = c;
            myPlayerNum = 1;
            setupListeners();
        });

        peer.on('error', (err) => {
            if (err.type === 'unavailable-id') {
                // å¦‚æœ ID é‡è¤‡ï¼Œè‡ªå‹•åˆ·æ–°é é¢é‡è©¦
                location.reload();
            } else {
                document.getElementById('status-msg').innerText = "é€£ç·šéŒ¯èª¤: " + err.type;
            }
        });
    }

    function connectToPeer() {
        const targetId = document.getElementById('peer-id-input').value.trim();
        if (!targetId) return;
        
        document.getElementById('status-msg').innerText = "â— æ­£åœ¨åŠ å…¥æˆ¿é–“ " + targetId + "...";
        conn = peer.connect(targetId);
        myPlayerNum = 2;
        setupListeners();
    }

    function setupListeners() {
        conn.on('open', () => {
            document.getElementById('status-msg').innerText = "â— é€£ç·šæˆåŠŸ";
            conn.send({ type: 'handshake' });
        });

        conn.on('data', (data) => {
            if (data.type === 'handshake') {
                startGameUI();
                if (myPlayerNum === 1) conn.send({ type: 'handshake' });
            } else if (data.type === 'move') {
                executeTurn(data.r, data.c, data.player);
            }
        });

        conn.on('close', () => {
            alert("å°æ‰‹æ–·ç·š");
            location.reload();
        });
    }

    function startGameUI() {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-container').style.display = 'flex';
        updateTurnDisplay();
        const labels = document.querySelectorAll('.player-label');
        if (myPlayerNum === 1) {
            labels[0].innerText = "æ‚¨ (ç´…æ–¹)";
            labels[1].innerText = "å°æ‰‹ (è—æ–¹)";
        } else {
            labels[0].innerText = "å°æ‰‹ (ç´…æ–¹)";
            labels[1].innerText = "æ‚¨ (è—æ–¹)";
        }
        createBoard();
    }

    // --- æ ¸å¿ƒé‚è¼¯è£œå®Œ ---
    function handleMove(r, c) {
        if (gameOver || currentTurnPlayer !== myPlayerNum || !conn || !conn.open) return;
        if (isValidMove(r, c, myPlayerNum)) {
            conn.send({ type: 'move', r, c, player: myPlayerNum });
            executeTurn(r, c, myPlayerNum);
        }
    }

    function executeTurn(r, c, player) {
        board[r][c] = player;
        growLines();
        findNewConnections(r, c, player);
        render();
        updateScore();
        if (!checkGameOver()) {
            currentTurnPlayer = (player === 1) ? 2 : 1;
            updateTurnDisplay();
        }
    }

    function updateTurnDisplay() {
        const d = document.getElementById('turn-display');
        d.innerText = currentTurnPlayer === myPlayerNum ? "â˜… æ‚¨çš„å›åˆ â˜…" : "ç­‰å¾…å°æ‰‹è½å­...";
        d.style.color = currentTurnPlayer === myPlayerNum ? "#f1c40f" : "#aaa";
    }

    function createBoard() {
        const b = document.getElementById('board');
        b.innerHTML = '';
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${r}-${c}`;
                cell.onclick = () => handleMove(r, c);
                b.appendChild(cell);
            }
        }
        render();
    }

    function getLinesAt(r, c) {
        return connectionsData.filter(t => t.path.some(p => p.r === r && p.c === c));
    }

    function isValidMove(r, c, player) {
        if (board[r][c] !== 0) return false;
        return !getLinesAt(r, c).some(l => l.player === (player === 1 ? 2 : 1));
    }

    function findNewConnections(r, c, player) {
        const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
        dirs.forEach(([dr, dc]) => {
            let cr = r + dr, cc = c + dc, found = false;
            while(cr >= 0 && cr < SIZE && cc >= 0 && cc < SIZE) {
                if (board[cr][cc] !== 0) {
                    if (board[cr][cc] === player) found = true;
                    break;
                }
                cr += dr; cc += dc;
            }
            if (found) connectionsData.push({ origin: {r, c}, target: {r: cr, c: cc}, dr, dc, player, path: [], active: true });
        });
    }

    function growLines() {
        connectionsData.forEach(task => {
            if (!task.active) return;
            const last = task.path.length === 0 ? task.origin : task.path[task.path.length - 1];
            const nr = last.r + task.dr, nc = last.c + task.dc;
            if (nr === task.target.r && nc === task.target.c) { task.active = false; return; }
            if (board[nr][nc] !== 0 && board[nr][nc] !== task.player) { task.active = false; return; }
            if (getLinesAt(nr, nc).some(l => (l.dr !== 0 ? 'v' : 'h') === (task.dr !== 0 ? 'v' : 'h'))) { task.active = false; return; }
            task.path.push({r: nr, c: nc});
        });
    }

    function render() {
        for(let r=0; r<SIZE; r++) {
            for(let c=0; c<SIZE; c++) {
                const cell = document.getElementById(`cell-${r}-${c}`);
                if (!cell) continue;
                cell.innerHTML = ''; cell.classList.remove('disputed');
                if (board[r][c] !== 0) {
                    const p = document.createElement('div');
                    p.className = `piece p${board[r][c]}`;
                    cell.appendChild(p);
                }
                const lines = getLinesAt(r, c);
                const h1 = lines.some(l => l.player === 1) || board[r][c] === 1;
                const h2 = lines.some(l => l.player === 2) || board[r][c] === 2;
                if (h1 && h2) cell.classList.add('disputed');
                lines.forEach(l => {
                    const lineEl = document.createElement('div');
                    lineEl.className = `line ${l.dr !== 0 ? 'v' : 'h'} p${l.player}`;
                    cell.appendChild(lineEl);
                });
            }
        }
    }

    function updateScore() {
        let p1 = 0, p2 = 0;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                const lines = getLinesAt(r, c);
                const h1 = board[r][c] === 1 || lines.some(l => l.player === 1);
                const h2 = board[r][c] === 2 || lines.some(l => l.player === 2);
                if (h1 && h2) continue; 
                if (h1) p1++; else if (h2) p2++;
            }
        }
        document.getElementById('p1-score').innerText = p1;
        document.getElementById('p2-score').innerText = p2;
        return { p1, p2 };
    }

    function checkGameOver() {
        let all = true;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (board[r][c] === 0 && getLinesAt(r, c).length === 0) { all = false; break; }
            }
            if (!all) break;
        }
        if (all) {
            gameOver = true;
            const s = updateScore();
            document.getElementById('overlay').style.display = 'flex';
            document.getElementById('final-p1').innerText = s.p1;
            document.getElementById('final-p2').innerText = s.p2;
            const wt = document.getElementById('win-text');
            if (s.p1 > s.p2) { wt.innerText = "ğŸ‰ ç´…æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p1').style.display = 'block'; }
            else if (s.p2 > s.p1) { wt.innerText = "ğŸ‰ è—æ–¹ å‹åˆ©ï¼"; document.getElementById('crown-p2').style.display = 'block'; }
            else { wt.innerText = "âš–ï¸ å¹³æ‰‹ï¼"; }
            return true;
        }
        return false;
    }

    function copyMyID() {
        const id = document.getElementById('my-id').innerText;
        if (id.includes("ç”Ÿæˆ")) return;
        navigator.clipboard.writeText(id).then(() => alert("æˆ¿è™Ÿå·²è¤‡è£½ï¼"));
    }

    initPeer();
</script>

</body>
</html>
